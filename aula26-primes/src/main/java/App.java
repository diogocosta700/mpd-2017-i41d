import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Spliterator;
import java.util.Spliterators.AbstractSpliterator;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.IntConsumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import static java.util.Spliterator.ORDERED;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            System.out.println("############################");
            System.out.println(measurePerformance(() -> primes(10000).count()));
            System.out.println(measurePerformance(() -> primes(10000, App::isPrimeOpt).count()));
            System.out.println(measurePerformance(() -> primes(10000, App::isPrimeOpt2).count()));
        }
    }

    public static IntStream primes(int max) {
        return IntStream
                .range(2, max + 1)
                .filter(candidate -> isPrimeStream(candidate));
    }

    public static IntStream primes(int max, BiFunction<List<Integer>, Integer, Boolean> isPrime) {
        List<Integer> prs = new ArrayList<>();
        return IntStream
                .range(2, max + 1)
                .filter(candidate -> isPrime.apply(prs, candidate));
    }
    /**
     * Version 4
     * Functional version of is prime algorithm with Stream.
     * Receives an additional List of already selected primes.
     * And iterate until Square root of candidate.
     */
    public static boolean isPrimeOpt2(List<Integer> primes, int candidate) {
        int root = (int) Math.sqrt(candidate);
        boolean notPrime = takeWhile(primes, div -> div <= root)
                .anyMatch(div -> candidate%div == 0);
        if(!notPrime) primes.add(candidate);
        return !notPrime;
    }

    /**
     * Version 3
     * Functional version of is prime algorithm with Stream.
     * Receives an additional List of already selected primes.
     */
    public static boolean isPrimeOpt(List<Integer> primes, int candidate) {
        boolean notPrime = primes
                .stream()
                .anyMatch(div -> candidate%div == 0);
        if(!notPrime) primes.add(candidate);
        return !notPrime;
    }
    /**
     * Version 2
     * Functional version of is prime algorithm with Stream.
     */
    public static boolean isPrimeStream(int candidate) {
        /*
        return IntStream
                .range(2, candidate)
                .filter(div -> candidate%div == 0)
                .count() == 0;
        */
        boolean notPrime = IntStream
                .range(2, candidate)
                .anyMatch(div -> candidate%div == 0);
        return !notPrime;
    }

    /**
     * Version 1
     * Iterative version of is prime algorithm.
     */
    public static boolean isPrimeImperative(int candidate) {
        for (int div = 2; div < candidate; div++) {
            if(candidate%div == 0) return false;
        }
        return true;
    }

    /**
     * !!!! Do not Use for reliable performance tests.
     * For accurate micro benchmarking you must use JMH!!!!
     */
    private static <T> T measurePerformance(Supplier<T> action) {
        T val = null;
        long min = Long.MAX_VALUE;
        for (int i = 0; i < 100; i++) {
            long init = System.nanoTime();
            val = action.get();
            long dur = System.nanoTime() - init;
            if(dur < min) min = dur;
        }
        min = min / 1000;
        System.out.println("Duration = " + min + "us");
        return val;
    }

    private static <T> Stream<T> takeWhile(List<T> src, Predicate<T> p) {
        Spliterator<T> iter = src.spliterator();
        Spliterator<T> res = new AbstractSpliterator<T>(Long.MAX_VALUE, Spliterator.ORDERED) {
            private boolean hasNext = true;
            @Override
            public boolean tryAdvance(Consumer<? super T> action) {
                if(hasNext)
                    return iter.tryAdvance(item -> {
                        if(p.test(item)) action.accept(item);
                        else hasNext = false;
                    }) && hasNext;
                return false;
            }
        };
        return StreamSupport.stream(res, false);
    }
}
